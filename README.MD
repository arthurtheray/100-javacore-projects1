# Описание
Начинаю челлендж: 100 программ по javacore за 100 дней
Список программ заданий для написания программ составил GPT-5 Thinking
Вот промпт:

`
Составь список из 100 заданий на написание программ на java. Каждое задание должно содержать описание требуемой программы и требования по тому, что можно или что нельзя использовать при написании программы. Сложность заданий должна прогрессировать от первого к последнему заданию. Среди всех заданий должны быть охвачены все разделы java-core. Написание каждой программы должно занимать не более двух часов работы начинающего программиста Цель: наработать практические навыки программирования и закрепить теоретические знания о java-core
`

## Начало: 03.10.2025 18:40
## Планируемое завершение: 03.12.2025
## Фактическая дата завершения: 

# Как работать с набором заданий

1. Иди по порядку — сложность растёт плавно.
2. Внимательно соблюдай ограничения — именно они тренируют конкретную тему.
3. Если застрял — упрощай ввод/вывод, но не нарушай требования.
4. Пиши небольшие тестовые сценарии main, логику — в отдельных методах/классах.

# 100 задач

1. Привет, мир+, форматированный вывод. Написать программу, печатающую имя, возраст и любимое число в одной строке. Требования: использовать System.out.printf; не использовать Scanner.


2. Арифметика над целыми. Считать из аргументов командной строки два int, вывести сумму/разность/произведение/частное. Требования: обработать деление на ноль через if; без исключений.


3. Конвертер температуры. Перевод C↔F. Требования: использовать double и Math.round; без сторонних библиотек.


4. Калькулятор со switch. Операции + - * / по символу. Требования: switch обязателен; не использовать if-else для выбора операции.


5. Чётность и знак. Определить чётность и знак числа. Требования: тернарный оператор для одного из выводов; без switch.


6. Сумма цифр. Подсчитать сумму цифр натурального числа. Требования: цикл while; без строк/массивов.


7. Таблица умножения. Вывести 10×10. Требования: двойной for; форматированный вывод.


8. Минимум из трёх. Найти минимум из трёх чисел. Требования: написать собственный метод min3; без Math.min цепочкой.


9. Факториал итеративно. Вычислить n!. Требования: long; без рекурсии.


10. Число Фибоначчи. Вычислить n-е число. Требования: итеративно с двумя переменными; без массивов.


11. Реверс числа. Перевернуть цифры. Требования: арифметика; без строк.


12. Простое ли число. Проверить простоту. Требования: перебор до √n; без коллекций.


13. Сумма массива. Ввести массив и найти сумму/среднее. Требования: использовать массив int[]; без ArrayList.


14. Поиск максимума в массиве. Вернуть индекс и значение. Требования: отдельный метод; без сортировки.


15. Слияние двух отсортированных массивов. Требования: два указателя; без Arrays.sort.


16. Удаление дубликатов в массиве. Сдвиг и заполнение нулями. Требования: однопроходный алгоритм; без коллекций.


17. Поворот массива на k вправо. Требования: реверсы подмассивов; без дополнительного массива.


18. Строковый палиндром. Проверить палиндром (игнорируя регистр и пробелы). Требования: StringBuilder.reverse запрещён; сравнение по индексам.


19. Подсчёт слов. Количество слов в строке. Требования: разбивка по пробелам регуляркой \\s+; без ручного парсинга.


20. Частота символов. Посчитать частоты. Требования: массив на 256 или Map<Character,Integer> — на выбор; без Stream API.


21. Класс Point2D. Поля x,y, методы расстояния/сдвига. Требования: инкапсуляция с геттерами/сеттерами; toString обязателен.


22. Класс Rectangle. Площадь/периметр, содержит ли точку. Требования: перегрузка конструкторов; запрет статических полей.


23. Статический счётчик экземпляров. Класс, считающий созданные объекты. Требования: static поле; потокобезопасность не нужна.


24. Иммутабельный класс Money. Валюта + сумма. Требования: final поля, без сеттеров; проверка инвариантов в конструкторе.


25. Перегрузка методов. print(Object), print(int), print(String). Требования: показать выбор перегрузки; без вар-аргов.


26. Метод-утилита clamp. Ограничить значение в [min,max]. Требования: статический метод; без библиотек.


27. equals/hashCode для Person. Учитывать firstName,lastName,birthDate. Требования: контракты соблюдены; не использовать IDE-генерацию.


28. Сортировка пузырьком. Отсортировать массив. Требования: своя реализация; без Arrays.sort.


29. Бинарный поиск. В отсортированном массиве. Требования: вернуть индекс или -1; без рекурсии.


30. Двумерная матрица. Транспонирование. Требования: int[][]; без коллекций.


31. Наследование: Shape → Circle/Rectangle. Площадь/периметр через полиморфизм. Требования: базовый класс абстрактный; без instanceof.


32. Интерфейс Drawable. Реализовать у фигур draw() (текстовый вывод). Требования: интерфейс обязателен; без абстрактных классов.


33. Фабрика фигур. Возвращает Shape по типу строки. Требования: статическая фабрика; без new вне фабрики.


34. Шаблон Builder (ручной). Построить User с необязательными полями. Требования: вложенный статический Builder; без Lombok.


35. Композиция vs наследование. Класс Car с Engine (композиция). Требования: не наследоваться от Engine; toString.


36. Иерархия исключений. AppException → ValidationException/StorageException. Требования: checked исключения; перехват в main.


37. Переопределение compareTo. Student сортируется по gpa и имени. Требования: Comparable<Student>; без Comparator здесь.


38. Анонимный класс слушателя. Таймер, печатающий «тик». Требования: java.util.Timer + анонимный TimerTask; без лямбд.


39. Вложенные/внутренние классы. LinkedList собственной упрощённой реализации. Требования: внутренний Node класс; без коллекций JDK.


40. Enum DayOfWeek c логикой. Вернуть, рабочий ли день. Требования: методы у enum; без switch с числами.


41. Generics: Box<T>. Get/put, инвариантность. Требования: обобщённый класс; без необобщённых сырых типов.


42. Обобщённый метод maxOf. По Comparator. Требования: ограничение <T> с Comparator<? super T>; без стримов.


43. PECS тренировка. Копирование List<? super T> из List<? extends T>. Требования: отдельный утилитный метод; без Collections.copy.


44. Коллекции: список задач. CRUD над ArrayList<Task>. Требования: итератор для удаления; без индексов в удалении.


45. Set: уникальные email’ы. Очистка и нормализация. Требования: HashSet; без стримов.


46. Map: счётчик слов. Map<String,Integer>. Требования: getOrDefault или merge; без стримов.


47. Сортировка с Comparator. Список Person по фамилии, затем имени. Требования: цепочка thenComparing; без Comparable.


48. LinkedHashMap как кэш LRU (упрощённый). Ограничение по размеру. Требования: переопределить removeEldestEntry; без внешних библиотек.


49. PriorityQueue задачи по приоритету. Выталкивать самые важные. Требования: свой Comparator; без Comparable.


50. Deque для отмены/повтора. Реализовать undo/redo стек. Требования: ArrayDeque; без Stack.


51. Исключения: валидация ввода. Бросать IllegalArgumentException. Требования: try-catch в main; логирование через System.err.


52. Мульти-catch. Парсинг чисел и дат. Требования: catch (NumberFormatException | DateTimeParseException); без общего Exception.


53. try-with-resources. Копирование файла. Требования: Files.newInputStream/newOutputStream; без FileInputStream напрямую.


54. Чтение всего файла. Посчитать строки/слова/символы. Требования: Files.readAllLines; без Scanner.


55. Запись CSV. Экспорт списка объектов. Требования: экранировать запятые; без сторонних CSV библиотек.


56. Парсинг CSV. Импорт обратно. Требования: String.split с учётом кавычек — упрощённо; без внешних библиотек.


57. Сериализация Serializable. Сохранить/загрузить объект. Требования: ObjectOutputStream/ObjectInputStream; версия serialVersionUID.


58. Properties и конфиг. Загрузка/сохранение настроек. Требования: Properties.store/load; без JSON.


59. Regex: валидация телефона/email. Проверить несколько примеров. Требования: Pattern/Matcher; без онлайновых валидаторов.


60. Форматирование чисел и денег. Локализованный вывод. Требования: NumberFormat/Locale; без ручного форматирования.


61. Дата/время: разница дат. Сколько дней до ДР. Требования: LocalDate, Period; без старого Date.


62. Секундомер. Засечь длительность операции. Требования: Instant/Duration; без System.currentTimeMillis.


63. Планировщик напоминаний (консоль). Отфильтровать будущие события. Требования: LocalDateTime, сортировка; без БД.


64. Enum + switch. Тарифы и расчёт цены. Требования: switch по enum; без if-else цепочки.


65. Optional в API. Метод findUserById возвращает Optional<User>. Требования: использовать orElseThrow; без null возвратов.


66. StringBuilder оптимизация. Генерация большого текста. Требования: собрать 10000 строк; без конкатенации + в цикле.


67. Большие числа. Калькулятор BigDecimal с точностью. Требования: RoundingMode; без double.


68. Ассерты. Проверить инварианты в методах. Требования: ключевое слово assert; не использовать тестовые фреймворки.


69. Ресурсные бандлы. Локализация сообщений en/ru. Требования: ResourceBundle; без if (locale).


70. Пакеты и модулирование (без JPMS). Разложить классы по пакетам model/service/util. Требования: осмысленные package; без циклических зависимостей.


71. Лямбды: фильтр списка. Оставить строки длиннее N. Требования: Predicate<String>; без анонимных классов.


72. Функциональные интерфейсы. Написать TriFunction<A,B,C,R>. Требования: свой @FunctionalInterface; без библиотек.


73. Stream API: базовая обработка. Список чисел → квадрат → сумма. Требования: map+reduce; без циклов.


74. Группировка по полю. List<Person> → Map<City, List<Person>>. Требования: Collectors.groupingBy; без ручных циклов.


75. Подсчёт частот словами через стримы. Требования: flatMap, collect(Collectors.toMap(..., counting())); без merge.


76. Топ-K элементов. Найти 3 самых частых. Требования: стрим + sorted + limit; без PriorityQueue.


77. Параллельный стрим аккуратно. Обработать большой список чисел и измерить ускорение. Требования: parallel(); запрет состояния (side effects).


78. Коллектор свой. Реализовать Collector<Integer, ?, IntSummary> (мин/макс/сумма/кол-во). Требования: интерфейс Collector; без внешних либ.


79. Метод-ссылка. Сортировка по методу геттера. Требования: Comparator.comparing(Class::getter); без лямбды.


80. Optional комбинирование. Два Optional → вернуть сумму, если оба присутствуют. Требования: flatMap; без isPresent+get.


81. Потоки: создание и запуск. Запустить два Thread, печатающих счётчик. Требования: реализовать Runnable; без extends Thread.


82. Синхронизация. Потокобезопасный счётчик с synchronized. Требования: инкремент в критической секции; без AtomicInteger.


83. wait/notify. Производитель-потребитель с буфером на 1. Требования: монитор на общем объекте; без java.util.concurrent.


84. ExecutorService. Пул потоков для вычисления квадратов. Требования: Callable+Future; корректный shutdown.


85. Конкурентные коллекции. ConcurrentHashMap счётчик слов в нескольких потоках. Требования: compute; без внешней синхронизации.


86. Избежать deadlock. Два замка — упорядочить захват. Требования: демонстрация и исправление; без ReentrantLock.


87. ReentrantLock и Condition. Реализовать тот же буфер из (83). Требования: lock()/unlock() в try/finally.


88. AtomicInteger и CAS. Без synchronized сделать счётчик. Требования: incrementAndGet; без блокировок.


89. CompletableFuture база. Асинхронно скачать (эмулировать) данные, затем преобразовать. Требования: supplyAsync().thenApply(...); без блокирующего .get() в середине цепочки.


90. Параллельная обработка файлов. Посчитать суммарный размер файлов в каталоге. Требования: Files.walk + parallel(); без рекурсии вручную.


91. Рефлексия: печать полей класса. Вывести имена/типы полей любого объекта. Требования: Class.getDeclaredFields; без сторонних либ.


92. Рефлексия: вызов метода по имени. Вызвать sayHello(String) у объекта. Требования: getMethod/invoke; обработать исключения.


93. Кастомная аннотация @NotNull. Проверять поля объекта через рефлексию. Требования: Retention(RUNTIME) и Target(FIELD); без аспектов.


94. Простая валидация через аннотации. @Min, @Max на числах. Требования: написать валидатор; без Bean Validation (JSR-380).


95. Слабые ссылки. Счётчик размера WeakHashMap при потере ключей. Требования: продемонстрировать очистку; без явного GC вызова (допускается намёк).


96. Эхо-сервер (TCP) и клиент (консоль). Сервер отвечает тем же текстом. Требования: ServerSocket/Socket; один клиент, без нитей.


97. Логгер-обёртка. Своя минимальная прослойка над java.util.logging. Требования: настройка уровня; без сторонних логгеров.


98. Мини-CLI «Заметки». Команды add/list/find. Требования: хранение в файле; switch по командам; без БД/GUI.


99. Мини-ETL: чтение CSV → фильтр → запись CSV. Требования: Stream API для обработки; try-with-resources для I/O.


100. Мини-проект «Каталог книг». CRUD в памяти, поиск, сортировки, сохранение/загрузка, простая валидация. Требования: слои (model/service/io), equals/hashCode, Comparator, Optional, Streams, Files, обработка исключений; без фреймворков/БД/UI.