# Описание
Начинаю челлендж: 100 программ по javacore за 100 дней
Список программ заданий для написания программ составил GPT-5 Thinking
Вот промпт:

`
Составь список из 100 заданий на написание программ на java. Каждое задание должно содержать описание требуемой программы и требования по тому, что можно или что нельзя использовать при написании программы. Сложность заданий должна прогрессировать от первого к последнему заданию. Среди всех заданий должны быть охвачены все разделы java-core. Написание каждой программы должно занимать не более двух часов работы начинающего программиста Цель: наработать практические навыки программирования и закрепить теоретические знания о java-core
`

## Начало: 03.10.2025 18:40
## Планируемое завершение: 03.12.2025
## Фактическая дата завершения: 

# Как работать с набором заданий

1. Иди по порядку — сложность растёт плавно.
2. Внимательно соблюдай ограничения — именно они тренируют конкретную тему.
3. Если застрял — упрощай ввод/вывод, но не нарушай требования.
4. Пиши небольшие тестовые сценарии main, логику — в отдельных методах/классах.

# 100 задач

1. **Привет, мир+, форматированный вывод.** Написать программу, печатающую имя, возраст и любимое число в одной строке.
* Требования: использовать `System.out.printf`; не использовать `Scanner`.
* Теория: структура `main(String[] args)`, типы примитивов, строковые шаблоны `%d/%s/%.2f`, экранирование, разница `print/println/printf`.
* ☑03.10.2025

2. **Арифметика над целыми.** Считать из аргументов командной строки два `int`, вывести сумму/разность/произведение/частное.
* Требования: обработать деление на ноль через `if`; без исключений.
* Теория: аргументы командной строки, приведение типов `String→int` (`Integer.parseInt`), операторы `+ - * / %`, приоритет операций.
* ☑03.10.2025

3. **Конвертер температуры.** Перевод C↔F.
* Требования: использовать `double` и `Math.round`; без сторонних библиотек.
* Теория: `double` vs `float`, `Math` API (`round`, `pow`), погрешности с плавающей точкой.
* ☑04.10.2025

4. **Калькулятор со switch.** Операции `+ - * /` по символу.
* Требования: `switch` обязателен; не использовать `if-else` для выбора операции.
* Теория: `switch` по `char/String`, блоки `case`, `break`, значение по умолчанию `default`.
* ☑04.10.2025

5. **Чётность и знак.** Определить чётность и знак числа.
* Требования: тернарный оператор для одного из выводов; без `switch`.
* Теория: логические операторы, тернарный `?:`, остаток `%`, ветвление.
* ☑05.10.2025

6. **Сумма цифр.** Подсчитать сумму цифр натурального числа.
* Требования: цикл `while`; без строк/массивов.
* Теория: циклы `while/do-while`, целочисленное деление `/` и `%`, инварианты цикла.
* ☑05.10.2025

7. **Таблица умножения.** Вывести 10×10.
* Требования: двойной `for`; форматированный вывод.
* Теория: вложенные циклы, счётчики, выравнивание в `printf`.
* ☑05.10.2025

8. **Минимум из трёх.** Найти минимум из трёх чисел.
* Требования: написать собственный метод `min3`; без `Math.min` цепочкой.
* Теория: объявление методов, параметры/возвращаемые значения, область видимости.
* ☑05.10.2025

9. **Факториал итеративно.** Вычислить `n!`.
* Требования: `long`; без рекурсии.
* Теория: переполнение, диапазоны примитивов, итеративные алгоритмы.
* ☑06.10.2025

10. **Число Фибоначчи.** Вычислить n-е число.
* Требования: итеративно с двумя переменными; без массивов.
* Теория: последовательности, оптимизация по памяти, базовые и переходные случаи.
* ☑08.10.2025

11. **Реверс числа.** Перевернуть цифры.
* Требования: арифметика; без строк.
* Теория: модуль числа, работа с разрядами, отрицательные значения.
* ☑08.10.2025

12. **Простое ли число.** Проверить простоту.
* Требования: перебор до √n; без коллекций.
* Теория: сложность алгоритмов O(√n), `Math.sqrt`, ранний выход из цикла.
* ☑11.10.2025

13. **Сумма массива.** Ввести массив и найти сумму/среднее.
* Требования: использовать массив `int[]`; без `ArrayList`.
* Теория: объявление и инициализация массивов, длина массива, for-each.
* ☑11.10.2025

14. **Поиск максимума в массиве.** Вернуть индекс и значение.
* Требования: отдельный метод; без сортировки.
* Теория: линейный проход, хранение текущего лучшего значения/индекса.
* ☑12.10.2025

15. **Слияние двух отсортированных массивов.**
* Требования: два указателя; без `Arrays.sort`.
* Теория: техника двух указателей, стабильность слияния.
* ☑13.10.2025

16. **Удаление дубликатов в массиве.** Сдвиг и заполнение нулями.
* Требования: однопроходный алгоритм; без коллекций.
* Теория: инварианты, два указателя (slow/fast), изменение на месте (in-place).
* ☑14.10.2025

17. **Поворот массива на k вправо.**
* Требования: реверсы подмассивов; без дополнительного массива.
* Теория: реверс массива, циклические сдвиги, модульная арифметика.
* ☑17.10.2025

18. **Строковый палиндром.**
* Требования: `StringBuilder.reverse` запрещён; сравнение по индексам.
* Теория: `String` vs `StringBuilder`, нормализация регистра, `charAt`, `Character`.
* ☑17.10.2025

19. **Подсчёт слов.** Количество слов в строке.
* Требования: разбивка по пробелам регуляркой `\\s+`; без ручного парсинга.
* Теория: регулярные выражения, `String.split`, экранирование.
* ☑17.10.2025

20. **Частота символов.** Посчитать частоты.
* Требования: массив на 256 или `Map<Character,Integer>` — на выбор; без Stream API.
* Теория: `HashMap` базовые операции, автоупаковка/распаковка, кодировки по верхам.
* ☑18.10.2025

21. **Класс `Point2D`.** Поля `x,y`, методы расстояния/сдвига.
* Требования: инкапсуляция с геттерами/сеттерами; `toString` обязателен.
* Теория: ООП: инкапсуляция, `this`, `toString`, `Math.hypot`.
* ☑19.10.2025

22. **Класс `Rectangle`.** Площадь/периметр, содержит ли точку.
* Требования: перегрузка конструкторов; запрет статических полей.
* Теория: перегрузка конструкторов, `this()` вызовы, инварианты класса.
* ☑19.10.2025

23. **Статический счётчик экземпляров.**
* Требования: `static` поле; потокобезопасность не нужна.
* Теория: члены класса vs экземпляра, статические инициализаторы, область жизни.
* ☑19.10.2025

24. **Иммутабельный класс `Money`.** Валюта + сумма.
* Требования: `final` поля, без сеттеров; проверка инвариантов в конструкторе.
* Теория: иммутабельность, защитные копии, `BigDecimal` для денег (намёк).
* ☑20.10.2025

25. **Перегрузка методов.** `print(Object)`, `print(int)`, `print(String)`.
* Требования: показать выбор перегрузки; без вар-аргов.
* Теория: перегрузка vs переопределение, подбор перегрузки, автоупаковка.

26. **Метод-утилита `clamp`.** Ограничить значение в [min,max].
* Требования: статический метод; без библиотек.
* Теория: статические утилиты, предусловия/постусловия.
* ☑27.10.2025

27. **`equals`/`hashCode` для `Person`.**
* Требования: контракты соблюдены; не использовать IDE-генерацию.
* Теория: контракт `equals/hashCode`, симметрия/транзитивность, `Objects.equals/hash`.
* ☑27.10.2025

28. **Сортировка пузырьком.**
* Требования: своя реализация; без `Arrays.sort`.
* Теория: базовые сортировки, сравнение и обмен, оптимизация раннего выхода.
* ☑28.10.2025

29. **Бинарный поиск.**
* Требования: вернуть индекс или `-1`; без рекурсии.
* Теория: инварианты левой/правой границы, переполнение при `(l+r)/2`.

30. **Двумерная матрица.** Транспонирование.
* Требования: `int[][]`; без коллекций.
* Теория: зубчатые массивы, индексация `[i][j]`, обмен элементов.

31. **Наследование: `Shape` → `Circle/Rectangle`.**
* Требования: базовый класс абстрактный; без `instanceof`.
* Теория: наследование, абстрактные классы/методы, полиморфизм.

32. **Интерфейс `Drawable`.** `draw()` (текстовый вывод).
* Требования: интерфейс обязателен; без абстрактных классов.
* Теория: интерфейсы, реализация несколькими классами, контракт интерфейса.

33. **Фабрика фигур.**
* Требования: статическая фабрика; без `new` вне фабрики.
* Теория: шаблон Factory Method/Static Factory, инкапсуляция создания.

34. **Шаблон Builder (ручной).** `User` с необязательными полями.
* Требования: вложенный статический `Builder`; без Lombok.
* Теория: паттерн Builder, fluent-API, неизменяемые объекты.
* ☑02.11.2025

35. **Композиция vs наследование.** `Car` с `Engine`.
* Требования: не наследоваться от `Engine`; `toString`.
* Теория: композиция против наследования, делегирование.
* ☑03.11.2025

36. **Иерархия исключений.**
* Требования: checked исключения; перехват в `main`.
* Теория: `Throwable`→`Exception`/`RuntimeException`, checked vs unchecked, `throws`.
* ☑03.11.2025

37. **`compareTo` для `Student`.**
* Требования: `Comparable<Student>`; без `Comparator` здесь.
* Теория: контракт `compareTo`, порядок сортировки, согласованность с `equals`.
* ☑04.11.2025

38. **Анонимный класс слушателя.** Таймер «тик».
* Требования: `Timer` + анонимный `TimerTask`; без лямбд.
* Теория: анонимные классы, классы-обёртки задач, планирование `Timer`.
* ☑04.11.2025

39. **Вложенные/внутренние классы.** Свой `LinkedList`.
* Требования: внутренний `Node`; без коллекций JDK.
* Теория: nested/inner classes, доступ к полям внешнего класса.
* ☑09.11.2025

40. **Enum `DayOfWeek` c логикой.**
* Требования: методы у enum; без `switch` с числами.
* Теория: `enum` как класс, поля/методы/конструкторы enum.

41. **Generics: `Box<T>`.**
* Требования: обобщённый класс; без сырых типов.
* Теория: обобщения (generics), стирание типов (erasure), инвариантность.
* ☑04.11.2025

42. **Обобщённый метод `maxOf`.** По `Comparator`.
* Требования: `<T>` с `Comparator<? super T>`; без стримов.
* Теория: верхние/нижние ограничения (`extends/super`), wildcard-и.
* ☑16.11.2025

43. **PECS тренировка.** Копирование между списками.
* Требования: `List<? super T>` из `List<? extends T>`; без `Collections.copy`.
* Теория: принцип PECS (Producer Extends, Consumer Super).
* ☑16.11.2025

44. **Коллекции: список задач.** CRUD над `ArrayList<Task>`.
* Требования: итератор для удаления; без индексов в удалении.
* Теория: `List` API, `Iterator` и `iterator.remove`, fail-fast.
* ☑19.11.2025

45. **Set: уникальные email’ы.**
* Требования: `HashSet`; без стримов.
* Теория: множества, равенство и хеширование, нормализация строк.
* ☑23.11.2025

46. **Map: счётчик слов.**
* Требования: `getOrDefault` или `merge`; без стримов.
* Теория: `Map` API, `putIfAbsent/merge`, неизменяемые ключи.
* ☑23.11.2025

47. **Сортировка с `Comparator`.**
* Требования: `thenComparing`; без `Comparable`.
* Теория: компараторы, метод-референсы, стабильность сортировки.

48. **`LinkedHashMap` как LRU.**
* Требования: `removeEldestEntry`; без внешних библиотек.
* Теория: порядок итерации вставки/доступа, переопределение поведения.

49. **`PriorityQueue` задачи по приоритету.**
* Требования: свой `Comparator`; без `Comparable`.
* Теория: очередь с приоритетом (минимальная куча), сложность операций.

50. **`Deque` для undo/redo`.**
* Требования: `ArrayDeque`; без `Stack`.
* Теория: двусторонняя очередь, шаблон команд (вкратце), push/pop.

51. **Исключения: валидация ввода.**
* Требования: бросать `IllegalArgumentException`; `try-catch` в `main`.
* Теория: проектирование API, пред- и постусловия, обработка и логирование.

52. **Мульти-catch.** Парсинг чисел и дат.
* Требования: `catch (NumberFormatException | DateTimeParseException)`; без общего `Exception`.
* Теория: многоцелевой `catch`, порядок `catch`-блоков, специфичность.

53. **try-with-resources.** Копирование файла.
* Требования: `Files.newInputStream/newOutputStream`; без `FileInputStream` напрямую.
* Теория: `AutoCloseable`, утечки ресурсов, `Paths`/`Files`.

54. **Чтение всего файла.** Строки/слова/символы.
* Требования: `Files.readAllLines`; без `Scanner`.
* Теория: кодировки (`Charset`), работа со списками строк.

55. **Запись CSV.** Экспорт списка объектов.
* Требования: экранировать запятые; без сторонних CSV.
* Теория: экранирование, `StringJoiner`, `Files.write`.

56. **Парсинг CSV.** Импорт обратно.
* Требования: `String.split` с кавычками — упрощённо; без библиотек.
* Теория: тонкости `split`, регулярки для кавычек, обработка краёв.

57. **Сериализация `Serializable`.**
* Требования: `ObjectOutputStream/ObjectInputStream`; `serialVersionUID`.
* Теория: механизм сериализации Java, совместимость версий.

58. **`Properties` и конфиг.**
* Требования: `Properties.store/load`; без JSON.
* Теория: ключ-значение, поток ввода/вывода, комментарии в `.properties`.

59. **Regex: телефон/email.**
* Требования: `Pattern`/`Matcher`; без онлайн-валидаторов.
* Теория: компиляция шаблонов, группы, квантификаторы, флаги.

60. **Форматирование чисел и денег.**
* Требования: `NumberFormat`/`Locale`; без ручного форматирования.
* Теория: локали, группировка разрядов, валютные форматы.

61. **Дата/время: разница дат.** Дни до ДР.
* Требования: `LocalDate`, `Period`; без старого `Date`.
* Теория: `java.time` API, календарная vs абсолютная разница.

62. **Секундомер.** Засечь длительность операции.
* Требования: `Instant`/`Duration`; без `System.currentTimeMillis`.
* Теория: монотонные vs системные часы (в контексте), измерение интервалов.

63. **Планировщик напоминаний (консоль).**
* Требования: `LocalDateTime`, сортировка; без БД.
* Теория: сравнение дат-времени, `Comparator`, форматирование `DateTimeFormatter`.

64. **`Enum` + `switch`.** Тарифы и цена.
* Требования: `switch` по enum; без `if-else`.
* Теория: `switch` выражение (в новых версиях), методы в enum.

65. **`Optional` в API.** `findUserById`.
* Требования: `orElseThrow`; без `null` возвратов.
* Теория: семантика `Optional`, анти-паттерны (`Optional` в полях), методы `map/flatMap`.

66. **`StringBuilder` оптимизация.**
* Требования: собрать 10000 строк; без `+` в цикле.
* Теория: неизменяемость `String`, амортизированная сложность `StringBuilder`.

67. **Большие числа.** Калькулятор `BigDecimal`.
* Требования: `RoundingMode`; без `double`.
* Теория: масштаб и точность, контекст математических операций.

68. **Ассерты.** Проверить инварианты.
* Требования: `assert`; не использовать тестовые фреймворки.
* Теория: включение/assertion status (`-ea`), когда уместны.

69. **Ресурсные бандлы.** Локализация `en/ru`.
* Требования: `ResourceBundle`; без `if (locale)`.
* Теория: подбор ресурсов по иерархии локалей, файлы `*.properties`.

70. **Пакеты и модулирование (без JPMS).**
* Требования: `model/service/util`; без циклических зависимостей.
* Теория: пакеты, `package`-видимость, организация кода, импорт.

71. **Лямбды: фильтр списка.**
* Требования: `Predicate<String>`; без анонимных классов.
* Теория: лямбда-выражения, функциональные интерфейсы, замыкания (effectively final).

72. **Функциональные интерфейсы.** `TriFunction<A,B,C,R>`.
* Требования: свой `@FunctionalInterface`; без библиотек.
* Теория: аннотация `@FunctionalInterface`, default/static методы в интерфейсах.

73. **Stream API: квадрат → сумма.**
* Требования: `map`+`reduce`; без циклов.
* Теория: конвейерные операции, терминальные vs промежуточные, `reduce` и ассоциативность.

74. **Группировка по полю.**
* Требования: `Collectors.groupingBy`; без ручных циклов.
* Теория: коллектора, группировка/суммирование, изменения типа результата.

75. **Частоты словами через стримы.**
* Требования: `flatMap`, `toMap(..., counting())`.
* Теория: `flatMap` для разбиения, `Collectors.counting`, разрешение конфликтов ключей.

76. **Топ-K элементов.**
* Требования: `sorted` + `limit`; без `PriorityQueue`.
* Теория: сортировка по значению `Map.Entry`, компараторы, лимитирование.

77. **Параллельный стрим.** Измерить ускорение.
* Требования: `parallel()`; запрет side effects.
* Теория: параллельные стримы, разделение задач, проблемы общих состояний.

78. **Свой коллектор.** `Collector<Integer, ?, IntSummary>`.
* Требования: интерфейс `Collector`; без внешних либ.
* Теория: поставщик/аккумулятор/комбайнер/характеристики (`CONCURRENT`, `UNORDERED`).

79. **Метод-ссылка.** Сортировка по геттеру.
* Требования: `Comparator.comparing(Class::getter)`.
* Теория: ссылки на методы (`Class::instanceMethod`/`object::method`/`Class::new`).

80. **`Optional` комбинирование.**
* Требования: `flatMap`; без `isPresent()+get`.
* Теория: монадо-подобные операции, композиция опциональных значений.

81. **Потоки: создание и запуск.**
* Требования: реализовать `Runnable`; без `extends Thread`.
* Теория: модель потоков Java, состояние/жизненный цикл, `start` vs `run`.

82. **Синхронизация.** Потокобезопасный счётчик.
* Требования: `synchronized`; без `AtomicInteger`.
* Теория: монитор, критическая секция, видимость (`happens-before`), гонки.

83. **`wait/notify`.** Производитель-потребитель (буфер 1).
* Требования: монитор на общем объекте; без `java.util.concurrent`.
* Теория: ожидание/уведомление, спуриаус пробуждения, цикл `while` при ожидании.

84. **`ExecutorService`.** Пул потоков.
* Требования: `Callable`+`Future`; корректный `shutdown`.
* Теория: executors, отправка задач, получение результатов, политика завершения.

85. **Конкурентные коллекции.** `ConcurrentHashMap` счётчик слов.
* Требования: `compute`; без внешней синхронизации.
* Теория: сегментация/lock striping (в общих чертах), атомарные обновления.

86. **Избежать deadlock.**
* Требования: упорядочить захват; без `ReentrantLock`.
* Теория: взаимная блокировка: четыре условия, порядок/иерархия замков.

87. **`ReentrantLock` и `Condition`.** Буфер из (83).
* Требования: `try/finally` вокруг `lock()`.
* Теория: явные замки, условия, справедливость (`fair`), отличие от `synchronized`.

88. **`AtomicInteger` и CAS.** Счётчик без блокировок.
* Требования: `incrementAndGet`; без блокировок.
* Теория: атомики, compare-and-swap, отсутствие блокировок и продвинутые эффекты.

89. **`CompletableFuture` база.**
* Требования: `supplyAsync().thenApply(...)`; не блокировать по пути.
* Теория: цепочки задач, пулы по умолчанию (`ForkJoinPool.commonPool`), комбинирование.

90. **Параллельная обработка файлов.** Суммарный размер каталога.
* Требования: `Files.walk` + `parallel()`; без ручной рекурсии.
* Теория: файловая система NIO, ленивые стримы, фильтры `isRegularFile`.

91. **Рефлексия: печать полей.**
* Требования: `getDeclaredFields`.
* Теория: `Class` API, доступность (`setAccessible`), модификаторы полей.

92. **Рефлексия: вызов метода по имени.**
* Требования: `getMethod/invoke`; обработка исключений.
* Теория: сигнатуры методов, checked исключения рефлексии, перегрузки.

93. **Кастомная аннотация `@NotNull`.**
* Требования: `Retention(RUNTIME)`, `Target(FIELD)`.
* Теория: мета-аннотации, чтение аннотаций через рефлексию.

94. **Простая валидация через аннотации.** `@Min`, `@Max`.
* Требования: написать валидатор; без Bean Validation.
* Теория: дизайн аннотаций с параметрами, обход полей, отчёт об ошибках.

95. **Слабые ссылки.** `WeakHashMap` и сборка мусора.
* Требования: продемонстрировать очистку; без явного `System.gc()` (допустимо упоминание).
* Теория: ссылки `Strong/Soft/Weak/Phantom`, карты на слабых ключах, финализация (почему избегать).

96. **Эхо-сервер (TCP) и клиент.**
* Требования: `ServerSocket/Socket`; один клиент, без нитей.
* Теория: блокирующий I/O сокетов, потоки ввода/вывода, протоколы на уровне строк.

97. **Логгер-обёртка.** Над `java.util.logging`.
* Требования: уровни, хендлеры; без сторонних логгеров.
* Теория: `Logger`, `Level`, `Handler/Formatter`, иерархия логгеров.

98. **Мини-CLI «Заметки».** `add/list/find`.
* Требования: хранение в файле; `switch` по командам; без БД/GUI.
* Теория: дизайн простых CLI, парсинг аргументов, стратегия хранения (append vs overwrite).

99. **Мини-ETL: CSV → фильтр → CSV.**
* Требования: Stream API; try-with-resources для I/O.
* Теория: конвейерная обработка данных, `map/filter/collect`, управление ресурсами.

100. **Мини-проект «Каталог книг».** CRUD в памяти, поиск, сортировки, сохранение/загрузка, валидация.  
     * Требования: слои (`model/service/io`), `equals/hashCode`, `Comparator`, `Optional`, `Streams`, `Files`, обработка исключений; без фреймворков/БД/UI.  
     * Теория: базовая архитектура слоёв, разделение обязанностей, контракт коллекций, обработка ошибок как часть API, сериалиация/форматы хранения (CSV/Properties).