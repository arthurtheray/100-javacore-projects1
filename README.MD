# Описание
Начинаю челлендж: 100 программ по javacore за 100 дней
Список программ заданий для написания программ составил GPT-5 Thinking
Вот промпт:

`
Составь список из 100 заданий на написание программ на java. Каждое задание должно содержать описание требуемой программы и требования по тому, что можно или что нельзя использовать при написании программы. Сложность заданий должна прогрессировать от первого к последнему заданию. Среди всех заданий должны быть охвачены все разделы java-core. Написание каждой программы должно занимать не более двух часов работы начинающего программиста Цель: наработать практические навыки программирования и закрепить теоретические знания о java-core
`

## Начало: 03.10.2025 18:40
## Планируемое завершение: 03.12.2025
## Фактическая дата завершения: 

# Как работать с набором заданий

1. Иди по порядку — сложность растёт плавно.
2. Внимательно соблюдай ограничения — именно они тренируют конкретную тему.
3. Если застрял — упрощай ввод/вывод, но не нарушай требования.
4. Пиши небольшие тестовые сценарии main, логику — в отдельных методах/классах.

# 100 задач

1. **Привет, мир+, форматированный вывод.** Написать программу, печатающую имя, возраст и любимое число в одной строке.
* Требования: использовать `System.out.printf`; не использовать `Scanner`.
* Теория: структура `main(String[] args)`, типы примитивов, строковые шаблоны `%d/%s/%.2f`, экранирование, разница `print/println/printf`.
* ☑03.10.2025

2. **Арифметика над целыми.** Считать из аргументов командной строки два `int`, вывести сумму/разность/произведение/частное.
* Требования: обработать деление на ноль через `if`; без исключений.
* Теория: аргументы командной строки, приведение типов `String→int` (`Integer.parseInt`), операторы `+ - * / %`, приоритет операций.
* ☑03.10.2025

3. **Конвертер температуры.** Перевод C↔F.
* Требования: использовать `double` и `Math.round`; без сторонних библиотек.
* Теория: `double` vs `float`, `Math` API (`round`, `pow`), погрешности с плавающей точкой.
* ☑04.10.2025

4. **Калькулятор со switch.** Операции `+ - * /` по символу.
* Требования: `switch` обязателен; не использовать `if-else` для выбора операции.
* Теория: `switch` по `char/String`, блоки `case`, `break`, значение по умолчанию `default`.
* ☑04.10.2025

5. **Чётность и знак.** Определить чётность и знак числа.
* Требования: тернарный оператор для одного из выводов; без `switch`.
* Теория: логические операторы, тернарный `?:`, остаток `%`, ветвление.
* ☑05.10.2025

6. **Сумма цифр.** Подсчитать сумму цифр натурального числа.
* Требования: цикл `while`; без строк/массивов.
* Теория: циклы `while/do-while`, целочисленное деление `/` и `%`, инварианты цикла.
* ☑05.10.2025

7. **Таблица умножения.** Вывести 10×10.
* Требования: двойной `for`; форматированный вывод.
* Теория: вложенные циклы, счётчики, выравнивание в `printf`.
* ☑05.10.2025

8. **Минимум из трёх.** Найти минимум из трёх чисел.
   1. Требования: написать собственный метод `min3`; без `Math.min` цепочкой.
   2. Теория: объявление методов, параметры/возвращаемые значения, область видимости.
   3. ☑05.10.2025

9. **Факториал итеративно.** Вычислить `n!`.
   1. Требования: `long`; без рекурсии.
   2. Теория: переполнение, диапазоны примитивов, итеративные алгоритмы.
   3. ☑06.10.2025

10. **Число Фибоначчи.** Вычислить n-е число.
   1. Требования: итеративно с двумя переменными; без массивов.
   2. Теория: последовательности, оптимизация по памяти, базовые и переходные случаи.
   3. ☑08.10.2025

11. **Реверс числа.** Перевернуть цифры.
   1. Требования: арифметика; без строк.
   2. Теория: модуль числа, работа с разрядами, отрицательные значения.
   3. ☑08.10.2025

12. **Простое ли число.** Проверить простоту.
   1. Требования: перебор до √n; без коллекций.
   2. Теория: сложность алгоритмов O(√n), `Math.sqrt`, ранний выход из цикла.
   3. ☑11.10.2025

13. **Сумма массива.** Ввести массив и найти сумму/среднее.
   1. Требования: использовать массив `int[]`; без `ArrayList`.
   2. Теория: объявление и инициализация массивов, длина массива, for-each.
   3. ☑11.10.2025

14. **Поиск максимума в массиве.** Вернуть индекс и значение.
   1. Требования: отдельный метод; без сортировки.
   2. Теория: линейный проход, хранение текущего лучшего значения/индекса.
   3. ☑12.10.2025

15. **Слияние двух отсортированных массивов.**
   1. Требования: два указателя; без `Arrays.sort`.
   2. Теория: техника двух указателей, стабильность слияния.
   3. ☑13.10.2025

16. **Удаление дубликатов в массиве.** Сдвиг и заполнение нулями.
   1. Требования: однопроходный алгоритм; без коллекций.
   2. Теория: инварианты, два указателя (slow/fast), изменение на месте (in-place).
   3. ☑14.10.2025

17. **Поворот массива на k вправо.**
   1. Требования: реверсы подмассивов; без дополнительного массива.
   2. Теория: реверс массива, циклические сдвиги, модульная арифметика.
   3. ☑17.10.2025

18. **Строковый палиндром.**
   1. Требования: `StringBuilder.reverse` запрещён; сравнение по индексам.
   2. Теория: `String` vs `StringBuilder`, нормализация регистра, `charAt`, `Character`.
   3. ☑17.10.2025

19. **Подсчёт слов.** Количество слов в строке.
   1. Требования: разбивка по пробелам регуляркой `\\s+`; без ручного парсинга.
   2. Теория: регулярные выражения, `String.split`, экранирование.
   3. ☑17.10.2025

20. **Частота символов.** Посчитать частоты.
   1. Требования: массив на 256 или `Map<Character,Integer>` — на выбор; без Stream API.
   2. Теория: `HashMap` базовые операции, автоупаковка/распаковка, кодировки по верхам.
   3. ☑18.10.2025

21. **Класс `Point2D`.** Поля `x,y`, методы расстояния/сдвига.
   1. Требования: инкапсуляция с геттерами/сеттерами; `toString` обязателен.
   2. Теория: ООП: инкапсуляция, `this`, `toString`, `Math.hypot`.
   3. ☑19.10.2025

22. **Класс `Rectangle`.** Площадь/периметр, содержит ли точку.
   1. Требования: перегрузка конструкторов; запрет статических полей.
   2. Теория: перегрузка конструкторов, `this()` вызовы, инварианты класса.
   3. ☑19.10.2025

23. **Статический счётчик экземпляров.**
   1. Требования: `static` поле; потокобезопасность не нужна.
   2. Теория: члены класса vs экземпляра, статические инициализаторы, область жизни.
   3. ☑19.10.2025

24. **Иммутабельный класс `Money`.** Валюта + сумма.
   1. Требования: `final` поля, без сеттеров; проверка инвариантов в конструкторе.
   2. Теория: иммутабельность, защитные копии, `BigDecimal` для денег (намёк).
   3. ☑20.10.2025

25. **Перегрузка методов.** `print(Object)`, `print(int)`, `print(String)`.
   1. Требования: показать выбор перегрузки; без вар-аргов.
   2. Теория: перегрузка vs переопределение, подбор перегрузки, автоупаковка.

26. **Метод-утилита `clamp`.** Ограничить значение в [min,max].
   1. Требования: статический метод; без библиотек.
   2. Теория: статические утилиты, предусловия/постусловия.
3. ☑27.10.2025

27. **`equals`/`hashCode` для `Person`.**
   1. Требования: контракты соблюдены; не использовать IDE-генерацию.
   2. Теория: контракт `equals/hashCode`, симметрия/транзитивность, `Objects.equals/hash`.
3. ☑27.10.2025

28. **Сортировка пузырьком.**
   1. Требования: своя реализация; без `Arrays.sort`.
   2. Теория: базовые сортировки, сравнение и обмен, оптимизация раннего выхода.
3. ☑28.10.2025

29. **Бинарный поиск.**
   1. Требования: вернуть индекс или `-1`; без рекурсии.
   2. Теория: инварианты левой/правой границы, переполнение при `(l+r)/2`.

30. **Двумерная матрица.** Транспонирование.
   1. Требования: `int[][]`; без коллекций.
   2. Теория: зубчатые массивы, индексация `[i][j]`, обмен элементов.

31. **Наследование: `Shape` → `Circle/Rectangle`.**
   1. Требования: базовый класс абстрактный; без `instanceof`.
   2. Теория: наследование, абстрактные классы/методы, полиморфизм.

32. **Интерфейс `Drawable`.** `draw()` (текстовый вывод).
   1. Требования: интерфейс обязателен; без абстрактных классов.
   2. Теория: интерфейсы, реализация несколькими классами, контракт интерфейса.

33. **Фабрика фигур.**
   1. Требования: статическая фабрика; без `new` вне фабрики.
   2. Теория: шаблон Factory Method/Static Factory, инкапсуляция создания.

34. **Шаблон Builder (ручной).** `User` с необязательными полями.
   1. Требования: вложенный статический `Builder`; без Lombok.
   2. Теория: паттерн Builder, fluent-API, неизменяемые объекты.
3. ☑02.11.2025

35. **Композиция vs наследование.** `Car` с `Engine`.
   1. Требования: не наследоваться от `Engine`; `toString`.
   2. Теория: композиция против наследования, делегирование.
3. ☑03.11.2025

36. **Иерархия исключений.**
   1. Требования: checked исключения; перехват в `main`.
   2. Теория: `Throwable`→`Exception`/`RuntimeException`, checked vs unchecked, `throws`.
3. ☑03.11.2025

37. **`compareTo` для `Student`.**
   1. Требования: `Comparable<Student>`; без `Comparator` здесь.
   2. Теория: контракт `compareTo`, порядок сортировки, согласованность с `equals`.

38. **Анонимный класс слушателя.** Таймер «тик».
   1. Требования: `Timer` + анонимный `TimerTask`; без лямбд.
   2. Теория: анонимные классы, классы-обёртки задач, планирование `Timer`.
3. ☑04.11.2025

39. **Вложенные/внутренние классы.** Свой `LinkedList`.
   1. Требования: внутренний `Node`; без коллекций JDK.
   2. Теория: nested/inner classes, доступ к полям внешнего класса.

40. **Enum `DayOfWeek` c логикой.**
   1. Требования: методы у enum; без `switch` с числами.
   2. Теория: `enum` как класс, поля/методы/конструкторы enum.

41. **Generics: `Box<T>`.**
   1. Требования: обобщённый класс; без сырых типов.
   2. Теория: обобщения (generics), стирание типов (erasure), инвариантность.
3. ☑04.11.2025

42. **Обобщённый метод `maxOf`.** По `Comparator`.
   1. Требования: `<T>` с `Comparator<? super T>`; без стримов.
   2. Теория: верхние/нижние ограничения (`extends/super`), wildcard-и.

43. **PECS тренировка.** Копирование между списками.
   1. Требования: `List<? super T>` из `List<? extends T>`; без `Collections.copy`.
   2. Теория: принцип PECS (Producer Extends, Consumer Super).

44. **Коллекции: список задач.** CRUD над `ArrayList<Task>`.
   1. Требования: итератор для удаления; без индексов в удалении.
   2. Теория: `List` API, `Iterator` и `iterator.remove`, fail-fast.

45. **Set: уникальные email’ы.**
   1. Требования: `HashSet`; без стримов.
   2. Теория: множества, равенство и хеширование, нормализация строк.

46. **Map: счётчик слов.**
   1. Требования: `getOrDefault` или `merge`; без стримов.
   2. Теория: `Map` API, `putIfAbsent/merge`, неизменяемые ключи.

47. **Сортировка с `Comparator`.**
   1. Требования: `thenComparing`; без `Comparable`.
   2. Теория: компараторы, метод-референсы, стабильность сортировки.

48. **`LinkedHashMap` как LRU.**
   1. Требования: `removeEldestEntry`; без внешних библиотек.
   2. Теория: порядок итерации вставки/доступа, переопределение поведения.

49. **`PriorityQueue` задачи по приоритету.**
   1. Требования: свой `Comparator`; без `Comparable`.
   2. Теория: очередь с приоритетом (минимальная куча), сложность операций.

50. **`Deque` для undo/redo.**
   1. Требования: `ArrayDeque`; без `Stack`.
   2. Теория: двусторонняя очередь, шаблон команд (вкратце), push/pop.

51. **Исключения: валидация ввода.**
   1. Требования: бросать `IllegalArgumentException`; `try-catch` в `main`.
   2. Теория: проектирование API, пред- и постусловия, обработка и логирование.

52. **Мульти-catch.** Парсинг чисел и дат.
   1. Требования: `catch (NumberFormatException | DateTimeParseException)`; без общего `Exception`.
   2. Теория: многоцелевой `catch`, порядок `catch`-блоков, специфичность.

53. **try-with-resources.** Копирование файла.
   1. Требования: `Files.newInputStream/newOutputStream`; без `FileInputStream` напрямую.
   2. Теория: `AutoCloseable`, утечки ресурсов, `Paths`/`Files`.

54. **Чтение всего файла.** Строки/слова/символы.
   1. Требования: `Files.readAllLines`; без `Scanner`.
   2. Теория: кодировки (`Charset`), работа со списками строк.

55. **Запись CSV.** Экспорт списка объектов.
   1. Требования: экранировать запятые; без сторонних CSV.
   2. Теория: экранирование, `StringJoiner`, `Files.write`.

56. **Парсинг CSV.** Импорт обратно.
   1. Требования: `String.split` с кавычками — упрощённо; без библиотек.
   2. Теория: тонкости `split`, регулярки для кавычек, обработка краёв.

57. **Сериализация `Serializable`.**
   1. Требования: `ObjectOutputStream/ObjectInputStream`; `serialVersionUID`.
   2. Теория: механизм сериализации Java, совместимость версий.

58. **`Properties` и конфиг.**
   1. Требования: `Properties.store/load`; без JSON.
   2. Теория: ключ-значение, поток ввода/вывода, комментарии в `.properties`.

59. **Regex: телефон/email.**
   1. Требования: `Pattern`/`Matcher`; без онлайн-валидаторов.
   2. Теория: компиляция шаблонов, группы, квантификаторы, флаги.

60. **Форматирование чисел и денег.**
   1. Требования: `NumberFormat`/`Locale`; без ручного форматирования.
   2. Теория: локали, группировка разрядов, валютные форматы.

61. **Дата/время: разница дат.** Дни до ДР.
   1. Требования: `LocalDate`, `Period`; без старого `Date`.
   2. Теория: `java.time` API, календарная vs абсолютная разница.

62. **Секундомер.** Засечь длительность операции.
   1. Требования: `Instant`/`Duration`; без `System.currentTimeMillis`.
   2. Теория: монотонные vs системные часы (в контексте), измерение интервалов.

63. **Планировщик напоминаний (консоль).**
   1. Требования: `LocalDateTime`, сортировка; без БД.
   2. Теория: сравнение дат-времени, `Comparator`, форматирование `DateTimeFormatter`.

64. **`Enum` + `switch`.** Тарифы и цена.
   1. Требования: `switch` по enum; без `if-else`.
   2. Теория: `switch` выражение (в новых версиях), методы в enum.

65. **`Optional` в API.** `findUserById`.
   1. Требования: `orElseThrow`; без `null` возвратов.
   2. Теория: семантика `Optional`, анти-паттерны (`Optional` в полях), методы `map/flatMap`.

66. **`StringBuilder` оптимизация.**
   1. Требования: собрать 10000 строк; без `+` в цикле.
   2. Теория: неизменяемость `String`, амортизированная сложность `StringBuilder`.

67. **Большие числа.** Калькулятор `BigDecimal`.
   1. Требования: `RoundingMode`; без `double`.
   2. Теория: масштаб и точность, контекст математических операций.

68. **Ассерты.** Проверить инварианты.
   1. Требования: `assert`; не использовать тестовые фреймворки.
   2. Теория: включение/assertion status (`-ea`), когда уместны.

69. **Ресурсные бандлы.** Локализация `en/ru`.
   1. Требования: `ResourceBundle`; без `if (locale)`.
   2. Теория: подбор ресурсов по иерархии локалей, файлы `*.properties`.

70. **Пакеты и модулирование (без JPMS).**
   1. Требования: `model/service/util`; без циклических зависимостей.
   2. Теория: пакеты, `package`-видимость, организация кода, импорт.

71. **Лямбды: фильтр списка.**
   1. Требования: `Predicate<String>`; без анонимных классов.
   2. Теория: лямбда-выражения, функциональные интерфейсы, замыкания (effectively final).

72. **Функциональные интерфейсы.** `TriFunction<A,B,C,R>`.
   1. Требования: свой `@FunctionalInterface`; без библиотек.
   2. Теория: аннотация `@FunctionalInterface`, default/static методы в интерфейсах.

73. **Stream API: квадрат → сумма.**
   1. Требования: `map`+`reduce`; без циклов.
   2. Теория: конвейерные операции, терминальные vs промежуточные, `reduce` и ассоциативность.

74. **Группировка по полю.**
   1. Требования: `Collectors.groupingBy`; без ручных циклов.
   2. Теория: коллектора, группировка/суммирование, изменения типа результата.

75. **Частоты словами через стримы.**
   1. Требования: `flatMap`, `toMap(..., counting())`.
   2. Теория: `flatMap` для разбиения, `Collectors.counting`, разрешение конфликтов ключей.

76. **Топ-K элементов.**
   1. Требования: `sorted` + `limit`; без `PriorityQueue`.
   2. Теория: сортировка по значению `Map.Entry`, компараторы, лимитирование.

77. **Параллельный стрим.** Измерить ускорение.
   1. Требования: `parallel()`; запрет side effects.
   2. Теория: параллельные стримы, разделение задач, проблемы общих состояний.

78. **Свой коллектор.** `Collector<Integer, ?, IntSummary>`.
   1. Требования: интерфейс `Collector`; без внешних либ.
   2. Теория: поставщик/аккумулятор/комбайнер/характеристики (`CONCURRENT`, `UNORDERED`).

79. **Метод-ссылка.** Сортировка по геттеру.
   1. Требования: `Comparator.comparing(Class::getter)`.
   2. Теория: ссылки на методы (`Class::instanceMethod`/`object::method`/`Class::new`).

80. **`Optional` комбинирование.**
   1. Требования: `flatMap`; без `isPresent()+get`.
   2. Теория: монадо-подобные операции, композиция опциональных значений.

81. **Потоки: создание и запуск.**
   1. Требования: реализовать `Runnable`; без `extends Thread`.
   2. Теория: модель потоков Java, состояние/жизненный цикл, `start` vs `run`.

82. **Синхронизация.** Потокобезопасный счётчик.
   1. Требования: `synchronized`; без `AtomicInteger`.
   2. Теория: монитор, критическая секция, видимость (`happens-before`), гонки.

83. **`wait/notify`.** Производитель-потребитель (буфер 1).
   1. Требования: монитор на общем объекте; без `java.util.concurrent`.
   2. Теория: ожидание/уведомление, спуриаус пробуждения, цикл `while` при ожидании.

84. **`ExecutorService`.** Пул потоков.
   1. Требования: `Callable`+`Future`; корректный `shutdown`.
   2. Теория: executors, отправка задач, получение результатов, политика завершения.

85. **Конкурентные коллекции.** `ConcurrentHashMap` счётчик слов.
   1. Требования: `compute`; без внешней синхронизации.
   2. Теория: сегментация/lock striping (в общих чертах), атомарные обновления.

86. **Избежать deadlock.**
   1. Требования: упорядочить захват; без `ReentrantLock`.
   2. Теория: взаимная блокировка: четыре условия, порядок/иерархия замков.

87. **`ReentrantLock` и `Condition`.** Буфер из (83).
   1. Требования: `try/finally` вокруг `lock()`.
   2. Теория: явные замки, условия, справедливость (`fair`), отличие от `synchronized`.

88. **`AtomicInteger` и CAS.** Счётчик без блокировок.
   1. Требования: `incrementAndGet`; без блокировок.
   2. Теория: атомики, compare-and-swap, отсутствие блокировок и продвинутые эффекты.

89. **`CompletableFuture` база.**
   1. Требования: `supplyAsync().thenApply(...)`; не блокировать по пути.
   2. Теория: цепочки задач, пулы по умолчанию (`ForkJoinPool.commonPool`), комбинирование.

90. **Параллельная обработка файлов.** Суммарный размер каталога.
   1. Требования: `Files.walk` + `parallel()`; без ручной рекурсии.
   2. Теория: файловая система NIO, ленивые стримы, фильтры `isRegularFile`.

91. **Рефлексия: печать полей.**
   1. Требования: `getDeclaredFields`.
   2. Теория: `Class` API, доступность (`setAccessible`), модификаторы полей.

92. **Рефлексия: вызов метода по имени.**
   1. Требования: `getMethod/invoke`; обработка исключений.
   2. Теория: сигнатуры методов, checked исключения рефлексии, перегрузки.

93. **Кастомная аннотация `@NotNull`.**
   1. Требования: `Retention(RUNTIME)`, `Target(FIELD)`.
   2. Теория: мета-аннотации, чтение аннотаций через рефлексию.

94. **Простая валидация через аннотации.** `@Min`, `@Max`.
   1. Требования: написать валидатор; без Bean Validation.
   2. Теория: дизайн аннотаций с параметрами, обход полей, отчёт об ошибках.

95. **Слабые ссылки.** `WeakHashMap` и сборка мусора.
   1. Требования: продемонстрировать очистку; без явного `System.gc()` (допустимо упоминание).
   2. Теория: ссылки `Strong/Soft/Weak/Phantom`, карты на слабых ключах, финализация (почему избегать).

96. **Эхо-сервер (TCP) и клиент.**
   1. Требования: `ServerSocket/Socket`; один клиент, без нитей.
   2. Теория: блокирующий I/O сокетов, потоки ввода/вывода, протоколы на уровне строк.

97. **Логгер-обёртка.** Над `java.util.logging`.
   1. Требования: уровни, хендлеры; без сторонних логгеров.
   2. Теория: `Logger`, `Level`, `Handler/Formatter`, иерархия логгеров.

98. **Мини-CLI «Заметки».** `add/list/find`.
   1. Требования: хранение в файле; `switch` по командам; без БД/GUI.
   2. Теория: дизайн простых CLI, парсинг аргументов, стратегия хранения (append vs overwrite).

99. **Мини-ETL: CSV → фильтр → CSV.**
   1. Требования: Stream API; try-with-resources для I/O.
   2. Теория: конвейерная обработка данных, `map/filter/collect`, управление ресурсами.

100. **Мини-проект «Каталог книг».** CRUD в памяти, поиск, сортировки, сохранение/загрузка, валидация.  
     1. Требования: слои (`model/service/io`), `equals/hashCode`, `Comparator`, `Optional`, `Streams`, `Files`, обработка исключений; без фреймворков/БД/UI.  
     2. Теория: базовая архитектура слоёв, разделение обязанностей, контракт коллекций, обработка ошибок как часть API, сериалиация/форматы хранения (CSV/Properties).