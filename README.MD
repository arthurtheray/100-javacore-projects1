# Описание
Начинаю челлендж: 100 программ по javacore за 100 дней
Список программ заданий для написания программ составил GPT-5 Thinking
Вот промпт:

`
Составь список из 100 заданий на написание программ на java. Каждое задание должно содержать описание требуемой программы и требования по тому, что можно или что нельзя использовать при написании программы. Сложность заданий должна прогрессировать от первого к последнему заданию. Среди всех заданий должны быть охвачены все разделы java-core. Написание каждой программы должно занимать не более двух часов работы начинающего программиста Цель: наработать практические навыки программирования и закрепить теоретические знания о java-core
`

## Начало: 03.10.2025 18:40
## Планируемое завершение: 03.12.2025
## Фактическая дата завершения: 

# Как работать с набором заданий

1. Иди по порядку — сложность растёт плавно.
2. Внимательно соблюдай ограничения — именно они тренируют конкретную тему.
3. Если застрял — упрощай ввод/вывод, но не нарушай требования.
4. Пиши небольшие тестовые сценарии main, логику — в отдельных методах/классах.

# 100 задач

1. **Привет, мир+, форматированный вывод.** Написать программу, печатающую имя, возраст и любимое число в одной строке.
* Требования: использовать `System.out.printf`; не использовать `Scanner`.
* Теория: структура `main(String[] args)`, типы примитивов, строковые шаблоны `%d/%s/%.2f`, экранирование, разница `print/println/printf`.
* ☑03.10.2025

2. **Арифметика над целыми.** Считать из аргументов командной строки два `int`, вывести сумму/разность/произведение/частное.
* Требования: обработать деление на ноль через `if`; без исключений.
* Теория: аргументы командной строки, приведение типов `String→int` (`Integer.parseInt`), операторы `+ - * / %`, приоритет операций.
* ☑03.10.2025

3. **Конвертер температуры.** Перевод C↔F.
* Требования: использовать `double` и `Math.round`; без сторонних библиотек.
* Теория: `double` vs `float`, `Math` API (`round`, `pow`), погрешности с плавающей точкой.
* ☑04.10.2025

4. **Калькулятор со switch.** Операции `+ - * /` по символу.
* Требования: `switch` обязателен; не использовать `if-else` для выбора операции.
* Теория: `switch` по `char/String`, блоки `case`, `break`, значение по умолчанию `default`.
* ☑04.10.2025

5. **Чётность и знак.** Определить чётность и знак числа.
* Требования: тернарный оператор для одного из выводов; без `switch`.
* Теория: логические операторы, тернарный `?:`, остаток `%`, ветвление.
* ☑05.10.2025

6. **Сумма цифр.** Подсчитать сумму цифр натурального числа.
* Требования: цикл `while`; без строк/массивов.
* Теория: циклы `while/do-while`, целочисленное деление `/` и `%`, инварианты цикла.
* ☑05.10.2025

7. **Таблица умножения.** Вывести 10×10.
* Требования: двойной `for`; форматированный вывод.
* Теория: вложенные циклы, счётчики, выравнивание в `printf`.
* ☑05.10.2025

8. **Минимум из трёх.** Найти минимум из трёх чисел.
* Требования: написать собственный метод `min3`; без `Math.min` цепочкой.
* Теория: объявление методов, параметры/возвращаемые значения, область видимости.
* ☑05.10.2025

9. **Факториал итеративно.** Вычислить `n!`.
* Требования: `long`; без рекурсии.
* Теория: переполнение, диапазоны примитивов, итеративные алгоритмы.
* ☑06.10.2025

10. **Число Фибоначчи.** Вычислить n-е число.
* Требования: итеративно с двумя переменными; без массивов.
* Теория: последовательности, оптимизация по памяти, базовые и переходные случаи.
* ☑08.10.2025

11. **Реверс числа.** Перевернуть цифры.
* Требования: арифметика; без строк.
* Теория: модуль числа, работа с разрядами, отрицательные значения.
* ☑08.10.2025

12. **Простое ли число.** Проверить простоту.
* Требования: перебор до √n; без коллекций.
* Теория: сложность алгоритмов O(√n), `Math.sqrt`, ранний выход из цикла.
* ☑11.10.2025

13. **Сумма массива.** Ввести массив и найти сумму/среднее.
* Требования: использовать массив `int[]`; без `ArrayList`.
* Теория: объявление и инициализация массивов, длина массива, for-each.
* ☑11.10.2025

14. **Поиск максимума в массиве.** Вернуть индекс и значение.
* Требования: отдельный метод; без сортировки.
* Теория: линейный проход, хранение текущего лучшего значения/индекса.
* ☑12.10.2025

15. **Слияние двух отсортированных массивов.**
* Требования: два указателя; без `Arrays.sort`.
* Теория: техника двух указателей, стабильность слияния.
* ☑13.10.2025

16. **Удаление дубликатов в массиве.** Сдвиг и заполнение нулями.
* Требования: однопроходный алгоритм; без коллекций.
* Теория: инварианты, два указателя (slow/fast), изменение на месте (in-place).
* ☑14.10.2025

17. **Поворот массива на k вправо.**
* Требования: реверсы подмассивов; без дополнительного массива.
* Теория: реверс массива, циклические сдвиги, модульная арифметика.
* ☑17.10.2025

18. **Строковый палиндром.**
* Требования: `StringBuilder.reverse` запрещён; сравнение по индексам.
* Теория: `String` vs `StringBuilder`, нормализация регистра, `charAt`, `Character`.
* ☑17.10.2025

19. **Подсчёт слов.** Количество слов в строке.
* Требования: разбивка по пробелам регуляркой `\\s+`; без ручного парсинга.
* Теория: регулярные выражения, `String.split`, экранирование.
* ☑17.10.2025

20. **Частота символов.** Посчитать частоты.
* Требования: массив на 256 или `Map<Character,Integer>` — на выбор; без Stream API.
* Теория: `HashMap` базовые операции, автоупаковка/распаковка, кодировки по верхам.
* ☑18.10.2025

21. **Класс `Point2D`.** Поля `x,y`, методы расстояния/сдвига.
* Требования: инкапсуляция с геттерами/сеттерами; `toString` обязателен.
* Теория: ООП: инкапсуляция, `this`, `toString`, `Math.hypot`.
* ☑19.10.2025

22. **Класс `Rectangle`.** Площадь/периметр, содержит ли точку.
* Требования: перегрузка конструкторов; запрет статических полей.
* Теория: перегрузка конструкторов, `this()` вызовы, инварианты класса.
* ☑19.10.2025

23. **Статический счётчик экземпляров.**
* Требования: `static` поле; потокобезопасность не нужна.
* Теория: члены класса vs экземпляра, статические инициализаторы, область жизни.
* ☑19.10.2025

24. **Иммутабельный класс `Money`.** Валюта + сумма.
* Требования: `final` поля, без сеттеров; проверка инвариантов в конструкторе.
* Теория: иммутабельность, защитные копии, `BigDecimal` для денег (намёк).
* ☑20.10.2025

25. **Перегрузка методов.** `print(Object)`, `print(int)`, `print(String)`.
* Требования: показать выбор перегрузки; без вар-аргов.
* Теория: перегрузка vs переопределение, подбор перегрузки, автоупаковка.

26. **Метод-утилита `clamp`.** Ограничить значение в [min,max].
* Требования: статический метод; без библиотек.
* Теория: статические утилиты, предусловия/постусловия.
* ☑27.10.2025

27. **`equals`/`hashCode` для `Person`.**
* Требования: контракты соблюдены; не использовать IDE-генерацию.
* Теория: контракт `equals/hashCode`, симметрия/транзитивность, `Objects.equals/hash`.
* ☑27.10.2025

28. **Сортировка пузырьком.**
* Требования: своя реализация; без `Arrays.sort`.
* Теория: базовые сортировки, сравнение и обмен, оптимизация раннего выхода.
* ☑28.10.2025

29. **Бинарный поиск.**
* Требования: вернуть индекс или `-1`; без рекурсии.
* Теория: инварианты левой/правой границы, переполнение при `(l+r)/2`.

30. **Двумерная матрица.** Транспонирование.
* Требования: `int[][]`; без коллекций.
* Теория: зубчатые массивы, индексация `[i][j]`, обмен элементов.

31. **Наследование: `Shape` → `Circle/Rectangle`.**
* Требования: базовый класс абстрактный; без `instanceof`.
* Теория: наследование, абстрактные классы/методы, полиморфизм.

32. **Интерфейс `Drawable`.** `draw()` (текстовый вывод).
* Требования: интерфейс обязателен; без абстрактных классов.
* Теория: интерфейсы, реализация несколькими классами, контракт интерфейса.

33. **Фабрика фигур.**
* Требования: статическая фабрика; без `new` вне фабрики.
* Теория: шаблон Factory Method/Static Factory, инкапсуляция создания.

34. **Шаблон Builder (ручной).** `User` с необязательными полями.
* Требования: вложенный статический `Builder`; без Lombok.
* Теория: паттерн Builder, fluent-API, неизменяемые объекты.
* ☑02.11.2025

35. **Композиция vs наследование.** `Car` с `Engine`.
* Требования: не наследоваться от `Engine`; `toString`.
* Теория: композиция против наследования, делегирование.
* ☑03.11.2025

36. **Иерархия исключений.**
* Требования: checked исключения; перехват в `main`.
* Теория: `Throwable`→`Exception`/`RuntimeException`, checked vs unchecked, `throws`.
* ☑03.11.2025

37. **`compareTo` для `Student`.**
* Требования: `Comparable<Student>`; без `Comparator` здесь.
* Теория: контракт `compareTo`, порядок сортировки, согласованность с `equals`.
* ☑04.11.2025

38. **Анонимный класс слушателя.** Таймер «тик».
* Требования: `Timer` + анонимный `TimerTask`; без лямбд.
* Теория: анонимные классы, классы-обёртки задач, планирование `Timer`.
* ☑04.11.2025

39. **Вложенные/внутренние классы.** Свой `LinkedList`.
* Требования: внутренний `Node`; без коллекций JDK.
* Теория: nested/inner classes, доступ к полям внешнего класса.
* ☑09.11.2025

40. **Enum `DayOfWeek` c логикой.**
* Требования: методы у enum; без `switch` с числами.
* Теория: `enum` как класс, поля/методы/конструкторы enum.

41. **Generics: `Box<T>`.**
* Требования: обобщённый класс; без сырых типов.
* Теория: обобщения (generics), стирание типов (erasure), инвариантность.
* ☑04.11.2025

42. **Обобщённый метод `maxOf`.** По `Comparator`.
* Требования: `<T>` с `Comparator<? super T>`; без стримов.
* Теория: верхние/нижние ограничения (`extends/super`), wildcard-и.
* ☑16.11.2025

43. **PECS тренировка.** Копирование между списками.
* Требования: `List<? super T>` из `List<? extends T>`; без `Collections.copy`.
* Теория: принцип PECS (Producer Extends, Consumer Super).
* ☑16.11.2025

44. **Коллекции: список задач.** CRUD над `ArrayList<Task>`.
* Требования: итератор для удаления; без индексов в удалении.
* Теория: `List` API, `Iterator` и `iterator.remove`, fail-fast.
* ☑19.11.2025

45. **Set: уникальные email’ы.**
* Требования: `HashSet`; без стримов.
* Теория: множества, равенство и хеширование, нормализация строк.
* ☑23.11.2025

46. **Map: счётчик слов.**
* Требования: `getOrDefault` или `merge`; без стримов.
* Теория: `Map` API, `putIfAbsent/merge`, неизменяемые ключи.
* ☑23.11.2025

47. **Сортировка с `Comparator`.**
* Требования: `thenComparing`; без `Comparable`.
* Теория: компараторы, метод-референсы, стабильность сортировки. 
* ☑01.12.2025

48. **`LinkedHashMap` как LRU.**
* Требования: `removeEldestEntry`; без внешних библиотек.
* Теория: порядок итерации вставки/доступа, переопределение поведения.
* ☑07.12.2025

49. Очередь задач по приоритету (PriorityQueue)

Суть: реализовать диспетчер задач: на вход операции add(task, priority) и последовательность poll(); на выход — порядок выполнения от высокого приоритета к низкому.
Ограничения: использовать PriorityQueue с собственным Comparator; не использовать Comparable у task; без сторонних библиотек, без сортировки всей коллекции перед каждым poll.
Теория: PriorityQueue, компараторы, естественный vs заданный порядок, амортизированная сложность операций.
☑11.12.2025

50. Undo/Redo на Deque

Суть: консольное приложение с командами do <op>, undo, redo; на вход — поток команд; на выход — состояние после каждой команды.
Ограничения: использовать ArrayDeque (две деки: undo/redo); не использовать Stack, GUI или БД.
Теория: Deque, команды как объекты, push/pop, понятие стеков операций.
☑14.12.2025

51. Валидация ввода и исключения

Суть: функция парсинга настроек из строк: на вход строковые параметры; на выход — объект настроек или сообщение об ошибке.
Ограничения: бросать осмысленные IllegalArgumentException/NumberFormatException; ловить в main и печатать на System.err; 
без сторонних валидационных библиотек.
Теория: дизайн исключений, пред- и постусловия, обработка и сообщение об ошибке.
☑15.12.2025

52. Multi-catch парсинг чисел и дат

Суть: на вход строка вида YYYY-MM-DD;number; на выход — суммарная «оценка» (например, день года + число).
Ограничения: использовать catch (NumberFormatException | DateTimeParseException); не ловить общий Exception.
Теория: многоцелевой catch, порядок catch, специфичные vs общие исключения, java.time.
☑16.12.2025

53. Копирование файла (try-with-resources)

Суть: на вход путь источника и назначения; на выход — скопированный файл и время копирования.
Ограничения: Files.newInputStream/newOutputStream + try-with-resources; не использовать FileInputStream/FileOutputStream напрямую и сторонние IO-библиотеки.
Теория: AutoCloseable, NIO Files, управление ресурсами.

54. Подсчёт строк/слов/символов в файле

Суть: на вход путь к текстовому файлу; на выход — количество строк, слов, символов.
Ограничения: Files.readAllLines или поток строк Files.lines; без Scanner.
Теория: кодировки (Charset), работа со списками и стримами строк.

55. Запись CSV

Суть: на вход список объектов (например, Person); на выход — корректный CSV (с кавычками/экранированием).
Ограничения: без сторонних CSV-библиотек; корректно экранировать запятые и кавычки.
Теория: формат CSV, экранирование полей, StringJoiner, Files.write.

56. Парсинг CSV

Суть: на вход CSV-файл; на выход — список объектов.
Ограничения: допустимо упрощение: кавычки вокруг полей, запятые внутри кавычек; без библиотек.
Теория: регулярные выражения/ручной разбор, обработка границ и кавычек.

57. Сериализация объектов (Serializable)

Суть: сохранить объект в файл и загрузить обратно; на вход — объект; на выход — восстановленный объект (эквивалентность по equals).
Ограничения: ObjectOutputStream/ObjectInputStream; указать serialVersionUID; без внешних форматов.
Теория: механизм сериализации, совместимость версий, transient.

58. Конфиги через Properties

Суть: на вход ключ-значение конфигурации; на выход — файл .properties и возможность загрузки/изменения.
Ограничения: Properties.load/store; без JSON/YAML.
Теория: свойства, IO-потоки, комментарии и кодировки.

59. Regex-валидация телефона и email

Суть: на вход список строк; на выход — какие строки — корректный телефон/email.
Ограничения: Pattern/Matcher; без онлайн-валидаторов и сторонних либ.
Теория: регулярки, группы, квантификаторы, флаги.

60. Локализованное форматирование чисел/денег

Суть: на вход число и код локали/валюты; на выход — строка с форматированием.
Ограничения: NumberFormat, Locale, Currency; без ручной вставки разделителей.
Теория: локализация, валютные форматы, группировка.

61. Сколько дней до ДР

Суть: на вход LocalDate дня рождения; на выход — количество дней до следующего ДР.
Ограничения: LocalDate, Period; не использовать Date/Calendar.
Теория: java.time, сравнение дат, перенос года.

62. Секундомер

Суть: на вход исполняемая операция (например, сортировка массива); на выход — длительность выполнения.
Ограничения: Instant/Duration; не использовать System.currentTimeMillis.
Теория: системные vs монотонные часы (в контексте), измерение интервалов.

63. Консольный планировщик напоминаний

Суть: на вход список LocalDateTime событий и «сейчас»; на выход — ближайшие будущие события, отсортированные.
Ограничения: без БД/GUI; сортировка Comparator.
Теория: LocalDateTime, форматирование DateTimeFormatter, компараторы.

64. Тарифы и enum + switch

Суть: на вход тип тарифа и параметры; на выход — рассчитанная цена.
Ограничения: использовать switch по enum; не делать цепочку if-else.
Теория: enum с методами, switch-выражение (при желании), ветвление по константам.

65. API, возвращающее Optional

Суть: на вход идентификатор пользователя; на выход — Optional<User> с обработкой orElseThrow/orElse.
Ограничения: не возвращать null; без хранения Optional в полях.
Теория: семантика Optional, методы map/flatMap/orElseThrow.

66. Генерация большого текста с StringBuilder

Суть: на вход n; на выход — строка из n строк, собранная эффективно.
Ограничения: без конкатенации + в цикле; использовать StringBuilder.
Теория: неизменяемость String, амортизированная стоимость.

67. Калькулятор на BigDecimal

Суть: на вход число1, число2, операция, масштаб/режим; на выход — корректный результат без потери точности.
Ограничения: не использовать double; только BigDecimal и RoundingMode.
Теория: масштаб и точность, округления, контекст математических операций.

68. Инварианты через assert

Суть: в нескольких методах проверить предусловия/постусловия; на вход — различные входы; на выход — падение при нарушении при включённых ассертам.
Ограничения: использовать ключевое слово assert; без тестовых фреймворков.
Теория: включение -ea, роль assertions, когда уместны.

69. Ресурсные бандлы и локализация

Суть: на вход локаль (en/ru); на выход — локализованные сообщения из ResourceBundle.
Ограничения: ResourceBundle; не делать if (locale).
Теория: поиск ресурсов по иерархии локалей, *.properties.

70. Пакеты и структура проекта

Суть: разнести классы по model/service/util, обновить импорты; на вход — набор классов; на выход — компилируемый модуль без циклических зависимостей.
Ограничения: без JPMS; корректные package и import.
Теория: области видимости пакетов, организация кода.

71. Фильтр списка лямбдой

Суть: на вход список строк и порог длины; на выход — новые строки длинее N.
Ограничения: использовать Predicate<String> и лямбду; не использовать анонимный класс.
Теория: лямбды, функциональные интерфейсы, effectively final.

72. Свой функциональный интерфейс TriFunction

Суть: на вход три аргумента → один результат; продемонстрировать использование.
Ограничения: аннотация @FunctionalInterface; без сторонних либ.
Теория: функциональные интерфейсы, default/static методы.

73. Stream: квадраты и сумма

Суть: на вход список чисел; на выход — сумма квадратов.
Ограничения: map + reduce; не использовать циклы.
Теория: промежуточные/терминальные операции, ассоциативность reduce.

74. Группировка объектов

Суть: на вход List<Person>; на выход — Map<City, List<Person>>.
Ограничения: Collectors.groupingBy; без ручного заполнения карт.
Теория: коллекторы, изменение типа результата.

75. Частоты слов через Stream

Суть: на вход текст; на выход — Map<String,Long> с частотами.
Ограничения: flatMap, Collectors.toMap(..., counting()); без merge вручную.
Теория: разбиение потока, счётчики, разрешение конфликтов.

76. Топ-K по частоте

Суть: на вход Map<String,Long>; на выход — список топ-3 элементов по убыванию.
Ограничения: стрим entrySet().stream().sorted().limit(3); без PriorityQueue.
Теория: компараторы по Map.Entry, сортировка и лимит.

77. Параллельные стримы

Суть: на вход большой список чисел; на выход — время последовательной vs parallel() обработки и результат.
Ограничения: без состояния/побочных эффектов; только чистые операции.
Теория: параллельные стримы, разбиение, проблемы shared state.

78. Свой Collector (сводная статистика)

Суть: на вход Stream<Integer>; на выход — объект с min/max/sum/count.
Ограничения: реализовать Collector<A, Acc, R>; без внешних библиотек.
Теория: supplier/accumulator/combiner/finisher, characteristics.

79. Метод-ссылки в сортировке

Суть: на вход список объектов; на выход — отсортированный с Comparator.comparing(Class::getter).
Ограничения: использовать method reference, а не лямбду.
Теория: виды ссылок на методы (Class::static, Class::instance, obj::method).

80. Комбинирование двух Optional

Суть: на вход два Optional<Integer>; на выход — Optional<Integer> c суммой, если оба присутствуют.
Ограничения: использовать flatMap/map; не вызывать get/isPresent.
Теория: композиция опциональных значений.

81. Создание и запуск потоков

Суть: на вход — число итераций; на выход — вывод от двух параллельных Runnable (например, счётчики).
Ограничения: реализовать Runnable; не extends Thread.
Теория: жизненный цикл потока, start vs run.

82. Синхронизированный счётчик

Суть: на вход N инкрементов из нескольких потоков; на выход — корректное значение.
Ограничения: использовать synchronized; не использовать AtomicInteger.
Теория: мониторы, критическая секция, happens-before.

83. Производитель–потребитель (wait/notify)

Суть: на вход серия produce/consume; на выход — корректная последовательность обмена через буфер ёмкости 1.
Ограничения: wait/notify на общем мониторе; без java.util.concurrent.
Теория: ожидание/уведомление, спуриозные пробуждения, цикл while.

84. ExecutorService, Callable, Future

Суть: на вход список чисел; на выход — список квадратов, посчитанных пулом потоков, и корректное закрытие пула.
Ограничения: Executors.newFixedThreadPool, invokeAll/submit; корректный shutdown.
Теория: исполнители, задание/результат, завершение и таймауты.

85. Параллельный счётчик слов на ConcurrentHashMap

Суть: на вход массив строк; на выход — частоты слов, обновляемые из нескольких потоков.
Ограничения: ConcurrentHashMap.compute; без внешней синхронизации.
Теория: конкурентные коллекции, атомарные обновления.

86. Демонстрация и устранение дедлока

Суть: создать ситуацию взаимной блокировки на двух замках и показать исправление упорядочиванием захвата.
Ограничения: не использовать ReentrantLock; только synchronized.
Теория: четыре условия deadlock, порядок/иерархия замков.

87. ReentrantLock и Condition

Суть: реализовать буфер из (83) на ReentrantLock и двух Condition.
Ограничения: lock()/unlock() в try/finally; не использовать wait/notify.
Теория: явные замки, условия, справедливость (fair).

88. Безблокировочный счётчик на AtomicInteger

Суть: на вход N инкрементов; на выход — корректный итог без synchronized.
Ограничения: AtomicInteger.incrementAndGet(); без замков.
Теория: атомики, CAS, отсутствие блокировок.

89. База CompletableFuture

Суть: эмулировать асинхронную загрузку → трансформацию → объединение с другой задачей; на выход — результат и демонстрация неблокирующей цепочки.
Ограничения: supplyAsync, thenApply/thenCombine; избегать преждевременных .get() в середине.
Теория: цепочки задач, пул по умолчанию (ForkJoinPool), комбинирование.

90. Параллельная обработка файлов

Суть: на вход путь к каталогу; на выход — суммарный размер всех обычных файлов (в байтах).
Ограничения: Files.walk + стрим (возможно parallel()); без ручной рекурсии.
Теория: NIO Path/Files, ленивые стримы, фильтры.

91. Рефлексия: печать полей

Суть: на вход объект; на выход — имена/типы всех его полей (включая private).
Ограничения: getDeclaredFields, при необходимости setAccessible(true); без сторонних либ.
Теория: Class API, модификаторы, безопасность доступа.

92. Рефлексия: вызов метода по имени

Суть: на вход объект, имя метода и аргументы; на выход — результат вызова.
Ограничения: getMethod/getDeclaredMethod + invoke, корректная обработка исключений.
Теория: сигнатуры, перегрузки, checked-исключения рефлексии.

93. Аннотация @NotNull и проверка полей

Суть: на вход объект; на выход — список нарушений @NotNull на полях.
Ограничения: объявить аннотацию @Retention(RUNTIME) @Target(FIELD); пройтись рефлексией.
Теория: мета-аннотации, чтение аннотаций, отчёт об ошибках.

94. Валидация @Min/@Max

Суть: на вход объект с аннотированными числовыми полями; на выход — список нарушений границ.
Ограничения: без Bean Validation (JSR-380); только собственный валидатор.
Теория: аннотации с параметрами, рефлексия значений, формирование отчёта.

95. WeakHashMap и сборка мусора

Суть: показать, что записи исчезают, когда единственная сильная ссылка на ключ исчезает; на вход — добавление временных ключей; на выход — уменьшение размера карты после GC (допускается «намёк»).
Ограничения: использовать WeakHashMap; не вызывать активно System.gc() как «гарантию».
Теория: типы ссылок (Strong/Soft/Weak/Phantom), особенности WeakHashMap.

96. Эхо-сервер (TCP) и клиент

Суть: на вход строка от клиента; на выход — та же строка от сервера. Один клиент, последовательный режим.
Ограничения: ServerSocket/Socket, блочный IO; без нитей/селекторов/Netty.
Теория: сокеты, потоки ввода/вывода, протокол обмена строками.

97. Логгер-обёртка над java.util.logging

Суть: на вход сообщения разных уровней; на выход — консольный вывод с форматированием и управлением уровнем.
Ограничения: Logger, Handler, Formatter; не использовать SLF4J/Logback/Log4j.
Теория: иерархия логгеров, уровни, хендлеры/форматтеры.

98. Мини-CLI «Заметки»

Суть: команды add <text>, list, find <substr>; на вход — командная строка; на выход — соответствующий результат.
Ограничения: хранение в файле (текст), switch по командам; без БД/GUI.
Теория: парсинг аргументов, простые протоколы файлового хранения.

99. Мини-ETL: CSV → фильтр → CSV

Суть: на вход CSV; на выход — отфильтрованный CSV по условиям (например, цена > X).
Ограничения: Stream API для обработки; try-with-resources для IO; без внешних CSV-либ.
Теория: конвейер потоков (map/filter/collect), управление ресурсами.

100. Мини-проект «Каталог книг»
Суть: на вход команды CRUD в памяти (add/list/find/sort/save/load); на выход — корректные операции над коллекцией книг.
Ограничения: без БД/фреймворков/UI; слои model/service/io; equals/hashCode, Comparator, Optional, Streams, Files, обработка исключений.
Теория: базовая архитектура приложения, слои и ответственность, контракты коллекций, сериализация/CSV/Properties, исключения как часть API.